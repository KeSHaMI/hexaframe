from __future__ import annotations

import asyncio
from logging.config import fileConfig
import os
from typing import Optional

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, async_engine_from_config

# Interpret the config file for Python logging.
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Import target metadata from the app
# We assume the scaffolded project layout:
#   src/{{ package_name }}/interface/http/app.py (FastAPI app)
#   src/{{ package_name }}/db/base.py defines Base
try:
    from {{ package_name }}.db.base import Base  # type: ignore
    from {{ package_name }}.db.config import Settings  # type: ignore
except Exception as e:  # pragma: no cover - import-time errors should be surfaced to the user
    raise

target_metadata = Base.metadata


def get_database_url() -> str:
    # First: explicit env var set by user or compose
    url: Optional[str] = os.getenv("DATABASE_URL")
    if url:
        return url
    # Fallback: load from pydantic settings (reads .env)
    settings = Settings()  # type: ignore
    return settings.DATABASE_URL


def run_migrations_offline() -> None:
    """
    Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    """
    url = get_database_url()
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """
    Run migrations in 'online' mode using an AsyncEngine.
    """
    cfg_section = config.get_section(config.config_ini_section) or {}
    url = get_database_url()
    cfg_section["sqlalchemy.url"] = url

    connectable: AsyncEngine = async_engine_from_config(
        cfg_section,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
        future=True,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def main() -> None:
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        asyncio.run(run_migrations_online())


main()
