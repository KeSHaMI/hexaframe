from __future__ import annotations

from contextlib import asynccontextmanager
from fastapi import FastAPI

from hexaframe_fastapi import build_router

# Import DI container lazily to avoid import errors in tests that load this file directly.
# The scaffold installs the package editable, so absolute imports work at runtime.
def get_container():
    from {{ package_name }}.di import Container  # type: ignore
    return Container()


@asynccontextmanager
async def lifespan(app: FastAPI):
    container = get_container()
    try:
        # Store container on app.state for handlers/tests to retrieve
        app.state.container = container  # type: ignore[attr-defined]
        yield
    finally:
        await container.shutdown()


app = FastAPI(
    title="Hexaframe App",
    description="Starter FastAPI app scaffolded by hexaframe with DB/DI and a ping route.",
    version="0.1.0",
    lifespan=lifespan,
)

# Build ping endpoint using hexaframe_fastapi exactly like the previous scaffold.
# Keep POST /ping with PingIn/PingOut and concrete use case instance.
from pydantic import BaseModel, Field
from hexaframe.errors import ValidationError
from hexaframe.use_case import UseCase

class PingIn(BaseModel):
    name: str = Field(..., examples=["Alice"], description="Name to greet")

class PingOut(BaseModel):
    message: str = Field(..., examples=["hello, Alice"], description="Greeting message")

class Ping(UseCase[PingIn, PingOut]):
    def validate(self, input: PingIn) -> None:
        if not input.name:
            raise ValidationError("missing 'name'")

    def perform(self, input: PingIn) -> PingOut:
        return PingOut(message=f"hello, {input.name}")

def _parse_ping(body: dict) -> PingIn:
    return PingIn.model_validate(body)

# Explicitly annotate parser for adapter to infer request model in OpenAPI
_parse_ping.__annotations__ = {"body": dict, "return": PingIn}

def _map_ping_out(out: PingOut) -> dict:
    # Ensure JSON-serializable dict is returned
    return out.model_dump() if hasattr(out, "model_dump") else (out.dict() if hasattr(out, "dict") else out)

# Explicitly annotate mapper so adapter can infer response type if needed
_map_ping_out.__annotations__ = {"out": PingOut, "return": dict}

router = build_router(
    path="/ping",
    method="post",
    use_case=Ping(),
    input_parser=_parse_ping,
    # Use a named function reference instead of a lambda
    output_mapper=_map_ping_out,
    # Provide explicit response model for accurate response schema
    response_model=PingOut,
    summary="Wrapped",
)

app.include_router(router)
