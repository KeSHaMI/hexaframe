from __future__ import annotations

from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, Field

from hexaframe.errors import ValidationError
from hexaframe.use_case import UseCase
from hexaframe_fastapi import build_router


class PingIn(BaseModel):
    name: str = Field(..., examples=["Alice"], description="Name to greet")


class PingOut(BaseModel):
    message: str = Field(..., examples=["hello, Alice"], description="Greeting message")


class Ping(UseCase[PingIn, PingOut]):
    def validate(self, input: PingIn) -> None:
        if not input.name:
            raise ValidationError("missing 'name'")

    def perform(self, input: PingIn) -> PingOut:
        return PingOut(message=f"hello, {input.name}")


app = FastAPI(
    title="Hexaframe App",
    description="Starter FastAPI app scaffolded by hexaframe with typed request/response models for proper OpenAPI docs.",
    version="0.1.0",
)

def _parse_ping(body: dict) -> PingIn:
    return PingIn.model_validate(body)

# Explicitly annotate parser for adapter to infer request model in OpenAPI
_parse_ping.__annotations__ = {"body": dict, "return": PingIn}

def _map_ping_out(out: PingOut) -> dict:
    # Ensure JSON-serializable dict is returned
    return out.model_dump() if hasattr(out, "model_dump") else (out.dict() if hasattr(out, "dict") else out)

# Explicitly annotate mapper so adapter can infer response type if needed
_map_ping_out.__annotations__ = {"out": PingOut, "return": dict}

router = build_router(
    path="/ping",
    method="post",
    use_case=Ping(),
    input_parser=_parse_ping,
    # Use a named function reference instead of a lambda
    output_mapper=_map_ping_out,
    # Provide explicit response model for accurate response schema
    response_model=PingOut,
    summary="Wrapped",
)

app.include_router(router)
